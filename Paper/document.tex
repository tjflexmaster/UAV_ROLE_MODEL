%% bare_conf.tex
%% V1.2
%% 2002/11/18
%% by Michael Shell
%% mshell@ece.gatech.edu
%%
%% NOTE: This text file uses MS Windows line feed conventions. When (human)
%% reading this file on other platforms, you may have to use a text
%% editor that can handle lines terminated by the MS Windows line feed
%% characters (0x0D 0x0A).
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.6b or later) with an IEEE conference paper.
%%
%% Support sites:
%% http://www.ieee.org
%% and/or
%% http://www.ctan.org/tex-archive/macros/latex/contrib/supported/IEEEtran/
%%
%% This code is offered as-is - no warranty - user assumes all risk.
%% Free to use, distribute and modify.

% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. IEEE's font choices can trigger bugs that do  ***
% *** not appear when using other class files.                            ***
% Testflow can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/supported/IEEEtran/testflow


% Note that the a4paper option is mainly intended so that authors in
% countries using A4 can easily print to A4 and see how their papers will
% look in print. Authors are encouraged to use U.S. letter paper when
% submitting to IEEE. Use the testflow package mentioned above to verify
% correct handling of both paper sizes by the author's LaTeX system.
%
% Also note that the "draftcls" or "draftclsnofoot", not "draft", option
% should be used if it is desired that the figures are to be displayed in
% draft mode.
%
% This paper can be formatted using the peerreviewca
% (instead of conference) mode.
% If the IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it:
% \documentclass[conference]{IEEEtran}
% To use A4 paper, add a4paper option as in
% \documentclass[conference,a4paper]{IEEEtran}


% setup page to suit conference specification using fancyhdr
\documentclass[conference,letterpaper]{IEEEtran}
\usepackage{fancyhdr}
\setlength{\paperwidth}{215.9mm}
\setlength{\hoffset}{-9.7mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\textwidth}{184.3mm}
\setlength{\columnsep}{6.3mm}
\setlength{\marginparsep}{0mm}
\setlength{\marginparwidth}{0mm}

\setlength{\paperheight}{279.4mm}
\setlength{\voffset}{-7.4mm}
\setlength{\topmargin}{0mm}
\setlength{\headheight}{0mm}
\setlength{\headsep}{0mm}
\setlength{\topskip}{0mm}
\setlength{\textheight}{235.2mm}
\setlength{\footskip}{12.4mm}

\setlength{\parindent}{1pc}


% some very useful LaTeX packages include:

%\usepackage{cite}      % Written by Donald Arseneau
                        % V1.6 and later of IEEEtran pre-defines the format
                        % of the cite.sty package \cite{} output to follow
                        % that of IEEE. Loading the cite package will
                        % result in citation numbers being automatically
                        % sorted and properly "ranged". i.e.,
                        % [1], [9], [2], [7], [5], [6]
                        % (without using cite.sty)
                        % will become:
                        % [1], [2], [5]--[7], [9] (using cite.sty)
                        % cite.sty's \cite will automatically add leading
                        % space, if needed. Use cite.sty's noadjust option
                        % (cite.sty V3.8 and later) if you want to turn this
                        % off. cite.sty is already installed on most LaTeX
                        % systems. The latest version can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/supported/cite/

%\usepackage{graphicx}  % Written by David Carlisle and Sebastian Rahtz
                        % Required if you want graphics, photos, etc.
                        % graphicx.sty is already installed on most LaTeX
                        % systems. The latest version and documentation can
                        % be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/required/graphics/
                        % Another good source of documentation is "Using
                        % Imported Graphics in LaTeX2e" by Keith Reckdahl
                        % which can be found as esplatex.ps and epslatex.pdf
                        % at: http://www.ctan.org/tex-archive/info/
                        % NOTE: for dual use with latex and pdflatex, instead load graphicx like:
                        %\ifx\pdfoutput\undefined
                        %\usepackage{graphicx}
                        %\else
                        %\usepackage[pdftex]{graphicx}
                        %\fi
                        %
                        % However, be warned that pdflatex will require graphics to be in PDF
                        % (not EPS) format and will preclude the use of PostScript based LaTeX
                        % packages such as psfrag.sty and pstricks.sty. IEEE conferences typically
                        % allow PDF graphics (and hence pdfLaTeX). However, IEEE journals do not
                        % (yet) allow image formats other than EPS or TIFF. Therefore, authors of
                        % journal papers should use traditional LaTeX with EPS graphics.
                        %
                        % The path(s) to the graphics files can also be declared: e.g.,
                        % \graphicspath{{../eps/}{../ps/}}
                        % if the graphics files are not located in the same directory as the
                        % .tex file. This can be done in each branch of the conditional above
                        % (after graphicx is loaded) to handle the EPS and PDF cases separately.
                        % In this way, full path information will not have to be specified in
                        % each \includegraphics command.
                        %
                        % Note that, when switching from latex to pdflatex and vice-versa, the new
                        % compiler will have to be run twice to clear some warnings.

%\usepackage{psfrag}    % Written by Craig Barratt, Michael C. Grant,
                        % and David Carlisle
                        % This package allows you to substitute LaTeX
                        % commands for text in imported EPS graphic files.
                        % In this way, LaTeX symbols can be placed into
                        % graphics that have been generated by other
                        % applications. You must use latex->dvips->ps2pdf
                        % workflow (not direct pdf output from pdflatex) if
                        % you wish to use this capability because it works
                        % via some PostScript tricks. Alternatively, the
                        % graphics could be processed as separate files via
                        % psfrag and dvips, then converted to PDF for
                        % inclusion in the main file which uses pdflatex.
                        % Docs are in "The PSfrag System" by Michael C. Grant
                        % and David Carlisle. There is also some information
                        % about using psfrag in "Using Imported Graphics in
                        % LaTeX2e" by Keith Reckdahl which documents the
                        % graphicx package (see above). The psfrag package
                        % and documentation can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/supported/psfrag/

%\usepackage{subfigure} % Written by Steven Douglas Cochran
                        % This package makes it easy to put subfigures
                        % in your figures. i.e., "figure 1a and 1b"
                        % Docs are in "Using Imported Graphics in LaTeX2e"
                        % by Keith Reckdahl which also documents the graphicx
                        % package (see above). subfigure.sty is already
                        % installed on most LaTeX systems. The latest version
                        % and documentation can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/supported/subfigure/

%\usepackage{url}       % Written by Donald Arseneau
                        % Provides better support for handling and breaking
                        % URLs. url.sty is already installed on most LaTeX
                        % systems. The latest version can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/other/misc/
                        % Read the url.sty source comments for usage information.

%\usepackage{stfloats}  % Written by Sigitas Tolusis
                        % Gives LaTeX2e the ability to do double column
                        % floats at the bottom of the page as well as the top.
                        % (e.g., "\begin{figure*}[!b]" is not normally
                        % possible in LaTeX2e). This is an invasive package
                        % which rewrites many portions of the LaTeX2e output
                        % routines. It may not work with other packages that
                        % modify the LaTeX2e output routine and/or with other
                        % versions of LaTeX. The latest version and
                        % documentation can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/supported/sttools/
                        % Documentation is contained in the stfloats.sty
                        % comments as well as in the presfull.pdf file.
                        % Do not use the stfloats baselinefloat ability as
                        % IEEE does not allow \baselineskip to stretch.
                        % Authors submitting work to the IEEE should note
                        % that IEEE rarely uses double column equations and
                        % that authors should try to avoid such use.
                        % Do not be tempted to use the cuted.sty or
                        % midfloat.sty package (by the same author) as IEEE
                        % does not format its papers in such ways.

%\usepackage{amsmath}   % From the American Mathematical Society
                        % A popular package that provides many helpful commands
                        % for dealing with mathematics. Note that the AMSmath
                        % package sets \interdisplaylinepenalty to 10000 thus
                        % preventing page breaks from occurring within multiline
                        % equations. Use:
                        %\interdisplaylinepenalty=2500
                        % after loading amsmath to restore such page breaks
                        % as IEEEtran.cls normally does. amsmath.sty is already
                        % installed on most LaTeX systems. The latest version
                        % and documentation can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/


% Other popular packages for formatting tables and equations include:

%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty which improves the
% LaTeX2e array and tabular environments to provide better appearances and
% additional user controls. array.sty is already installed on most systems.
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/

% Mark Wooding's extremely powerful MDW tools, especially mdwmath.sty and
% mdwtab.sty which are used to format equations and tables, respectively.
% The MDWtools set is already installed on most LaTeX systems. The lastest
% version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/supported/mdwtools/


% V1.6 of IEEEtran contains the IEEEeqnarray family of commands that can
% be used to generate multiline equations as well as matrices, tables, etc.


% Also of notable interest:

% Scott Pakin's eqparbox package for creating (automatically sized) equal
% width boxes. Available:
% http://www.ctan.org/tex-archive/macros/latex/contrib/supported/eqparbox/


% Notes on hyperref:
% IEEEtran.cls attempts to be compliant with the hyperref package, written
% by Heiko Oberdiek and Sebastian Rahtz, which provides hyperlinks within
% a document as well as an index for PDF files (produced via pdflatex).
% However, it is a tad difficult to properly interface LaTeX classes and
% packages with this (necessarily) complex and invasive package. It is
% recommended that hyperref not be used for work that is to be submitted
% to the IEEE. Users who wish to use hyperref *must* ensure that their
% hyperref version is 6.72u or later *and* IEEEtran.cls is version 1.6b
% or later. The latest version of hyperref can be obtained at:
%
% http://www.ctan.org/tex-archive/macros/latex/contrib/supported/hyperref/
%
% Also, be aware that cite.sty (as of version 3.9, 11/2001) and hyperref.sty
% (as of version 6.72t, 2002/07/25) do not work optimally together.
% To mediate the differences between these two packages, IEEEtran.cls, as
% of v1.6b, predefines a command that fools hyperref into thinking that
% the natbib package is being used - causing it not to modify the existing
% citation commands, and allowing cite.sty to operate as normal. However,
% as a result, citation numbers will not be hyperlinked. Another side effect
% of this approach is that the natbib.sty package will not properly load
% under IEEEtran.cls. However, current versions of natbib are not capable
% of compressing and sorting citation numbers in IEEE's style - so this
% should not be an issue. If, for some strange reason, the user wants to
% load natbib.sty under IEEEtran.cls, the following code must be placed
% before natbib.sty can be loaded:
%
% \makeatletter
% \let\NAT@parse\undefined
% \makeatother
%
% Hyperref should be loaded differently depending on whether pdflatex
% or traditional latex is being used:
%
%\ifx\pdfoutput\undefined
%\usepackage[hypertex]{hyperref}
%\else
%\usepackage[pdftex,hypertexnames=false]{hyperref}
%\fi
%
% Pdflatex produces superior hyperref results and is the recommended
% compiler for such use.

\usepackage{fancyhdr}


% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor IEEEtran}

\begin{document}
% paper title
\title{Modeling UASs for Role Fusion and Human Machine Interface Optimization}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
% \author{\IEEEauthorblockN{Authors Name/s per 1st Affiliation}
% \IEEEauthorblockA{line 1 (of Affiliation): dept. name of organization\\
% line 2: name of organization, acronyms acceptable\\
% line 3: City, Country\\
% line 4: e-mail address if desired}
% \and
% \IEEEauthorblockN{Authors Name/s per 2nd Affiliation}
% \IEEEauthorblockA{line 1 (of Affiliation): dept. name of organization\\
% line 2: name of organization, acronyms acceptable\\
% line 3: City, Country\\
% line 4: e-mail address if desired}}


% avoiding spaces at the end of the author lines is not a problem with
% conference papers because we don't use \thanks or \IEEEmembership


% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
%
\author{TJ Gledhill, Jared Joseph Moore, Robert Ivie, Eric Mercer and Michael A.
Goodrich}


% use only for invited papers
%\specialpapernotice{(Invited Paper)}

% make the title area
\maketitle
\thispagestyle{plain}


% insert page header and footer here for IEEE PDF Compliant
\fancypagestyle{plain}{
\fancyhf{}	% clear all header and footer fields
\fancyfoot[L]{}
\fancyfoot[C]{}
\fancyfoot[R]{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
}


\pagestyle{fancy}{
\fancyhf{}
\fancyfoot[R]{}}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}



\begin{abstract}
% Many UASs require
% multiple operators each fulfilling a specialized role, often including at least
% a pilot and a payload operator who must coordinate to accomplish some mission.
% It is desirable to decrease the ratio of humans to UASs, ultimately inverting it
% so that one or a handful of humans can manage many UASs. We propose to project a
% UAS mission plan into a human workflow model, representing potential task
% sequences for each human role as a so-called Directed Role Graph (DiRG). Nodes
% in the graph represent mission events. Events that can be reliably managed by
% autonomy can be completely delegated to automatic control, but a human must be
% responsible for events that cannot or should not delegated. Execution of one
% role can be suspended to perform another role when required by pending events,
% allowing a single human to adopt a pilotâ€™s role when necessary but primarily
% performing the role of mission manager.


Recent research shows that wilderness search and rescue (WiSAR)
can be aided through the use of unmanned aerial systems (UASs). A
single UAS, however, requires several human operators to manage the
interface between the UAS vehicle and the larger search and rescue
operation. For UASs to scale to real-world wilderness
search and rescue scenarios, it is important to reduce operator
workload and mitigate the effects of stress and fatigue through
effective distributed control and augmented autonomy. A primary
challenge in any effort to understand distributed control is
effectively modeling the various roles in the system such as the human, GUI, and
physical enviroment.  This paper discusses a Java model that explicitly
formalizes the individual roles of the WiSAR UAS that can be model checked by
Java Pathfinder to establish its intended behavior. The model is the basis for
research on human machine interfaces to support combined human roles that reduce
operator workload. In essence, by modeling each individual role in WiSAR, it is
possible to perform role fusion and show that the new UAS is a correct
implementation of the original system with the addition of combined
roles, increased autonomy, and new interfaces. The experience of
this modeling activity suggests that modeling WiSAR or any system will be at
least as hard as any solution to distributed control or role fusion.
\end{abstract}

% \begin{abstract}
% Modeling complex environments for the purpose of simulating changes to those
% environments is a very challenging problem.  The modeling must have the proper
% level of abstraction, and the model must be verifiable using a verification
% tool.  Many of these tools require learning a new modeling/verification
% language.
% 
% In this work we present a java based modeling framework which does discrete time
% model simulation in the form of parallel state machines.  By defining the
% framework as java interfaces all modeling can be done in java.  This contrasts
% directly with modeling languages such as Brahms which uses a custom, strictly
% defined grammar.  We feel that this approach makes the modeling framework more
% robust in that it can fit a wider variety of discrete time domains while mapping
% the model to the simulation in a very minimalistic way.
% 
% Another benefit of using a java based framework is that the models can be easily
% ported into Java PathFinder for verification.  We validate this using a model of
% Unmanned Aerial Vehicle Enabled Wilderness Search and Rescue (UAV-enabled
% WiSAR).
% \end{abstract}


\begin{IEEEkeywords}
UAS Modeling, HMI Optimization
\end{IEEEkeywords}


% For peer review papers, you can put extra information on the cover
% page as needed:
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
%
% for peerreview papers, inserts a page break and creates the second title.
% Will be ignored for other modes.
\IEEEpeerreviewmaketitle

\section{Introduction}

\noindent\textbf{Problem Statement}: UASs require several human operators to
monitor and administer.

Unmanned Aerial Systems (UASs) most often require two human operators to 
control the Unmanned Aerial Vehicle (UAV). One operator controls flight while the
other controls the payloads such as sensors, cameras, or weapons.  In addition
to this a third human is responsible for overseeing task completion and
interfacing with the command structure.  It is preferable to relieve a
majority of this workload using augmented autonomy and enhanced
user interfaces.

A viable plan to relieve workload requires specific steps. First, model a specific UAS.
Second, change the model to minimize operator workload. Third, verify the effect
of those changes. Last, introduce those changes into a graphical user interface.
This paper focuses on the completion of the first objective, modeling a specific
UAS.

The specific UAS is the wilderness search and rescue
(WiSAR) UAS developed at Brigham Young University.  The WiSAR UAS is fairly
standard consisting of three humans, two GUIs, and a single UAV.

The model explicitly represents the various roles, which characterize the WiSAR UAS, as a
group of Mealy machines running in parallel.  A custom set of Java interfaces constitute
the model. These interfaces simulate a discrete time environment,
facilitate input/output between roles, and provide non-deterministic event
handling.

Java Pathfinder (JPF) checks the model. JPFÕs model checking is convenient
because JPF runs on the compiled Java code without a complicated conversion
process. You can find more information about how JPF functions, as well as a thorough
explanation of the model later in this paper.


%  Modeling UAV-enabled WiSAR with the proper amount of abstraction
% is a challenging task in itself.  Creating an accurate model that can be easily verified makes this much more difficult.  There are
% many tools available for model verification <insert a list of possible tools>,
% many of these tools require learning custom modeling languages, are designed for
% different domains, and use very strict grammars.  We believed that a modeling
% framework which uses a common language, uses a minimal grammar,
% and integrates with current verification tools would greatly help achieve our
% goals.
% 
% This paper presents a UAV-enabled WiSAR model constructed using a novel java
% based discrete time modeling framework which integrates directly with
% JavaPathfinder (JPF).  By modeling UAV-enabled WiSAR we show that this modeling framework does not require learning a new language,
% allows for modular abstraction of the model, and integrates directly with JPF.

\section{Related Work}

From video game creators to NASA researchers more people are
obsessed with finding, producing, and examining digital models of the real world.
Most want to better understand and verify real world events. Some people have
chosen to use Brahms as their medium. Brahms is a robust
modeling language that involves agent, geography, and object classes. These
classes are used to represent the people involved, their environment, and
the tools they have to work with.

NASA Ames Research Center is using Brahms to model interactions
between operators and their aerial equipment. These complex models have given
new understanding to both the instances studied and the language itself. In
their study of the Uberlingen collision the model, produced using the Brahms
language, Neha Rungta and her colleagues were able to correctly predict the
collision. Such a model could have forewarned the air traffic controller of the
collision.

Wilderness Search and Rescue is primarily concerned with finding people
who have become lost in rugged terrain. To further this goal they use
unmanned aerial vehicles (UAVs), which facilitate the work this group is doing. In
principle the vehicle searches for victims in areas that would be
difficult for ground teams to reach. Michael Goodrich and his colleagues tested
the effectiveness of these types of operations. They find that altitude and
video clarity determined the success of the mission. Furthermore they suppose
that these factors could be enhanced if the roles of the UAV operator and video
operator were combined. By modeling this role fusion the group can verify
new user interfaces before risking expensive equipment.

\section{WiSAR UAS Domain}

WiSAR represents search and rescue efforts in
remote, varying, and dangerous terrains.  According to T.J. Setnicka \ref{}
there are four core elements of a Wilderness Search and Rescue operation.  

\begin{figure}[h]
	\begin{center}
		\begin{math}
			Locate \Rightarrow Reach \Rightarrow Stabilize \Rightarrow Evacuate
		\end{math}
	\end{center}
	\caption{Core SAR Elements}
\end{figure}

The WiSAR UAS operates within this first element.  During the locate
phase the incident commander (IC) develops a strategy to obtain information, and
coordinates the overlying Parent Search (PS). The information obtaining
strategy makes use of the available tactics to be successful.  One
tactic may be using search dogs in a specific region or using a trained
tracker on the target's trail.

The WiSAR UAS is one of these tactics. It consists
of three humans: Mission Manager (MM), Operator (OP), and Video Operator(VO)
working with the Operator GUI (OGUI), Video Operator GUI (VGUI) and the UAV.  This team
coordinates its efforts with the PS which represents the entire
command structure for the search and rescue operation. The key roles, interfaces,
and objects of the WiSAR UAS emanate from human to human
interactions, human to UAV interactions, human to GUI interactions, unpredictable
outside stimulus, and varying task durations.


% The PS will give the MM a
% region which needs to be searched.  The MM will then direct the team in
% accomplishing this search task.  During the task the OP directs the flight path
% flown by the UAV.  The VO watches a video feed from the UAV looking for the
% described target.  If the VO views a likely target then a flyby request is made
% to the OP to fly over the anomaly in question until a decision can be made.  If
% it is believed to be the desired target then the sighting is reported to the MM
% who then reports to the PS.

\section{Simulating the WiSAR UAS}

In order to simulate critical aspects of the WiSAR UAS it becomes necessary to
model the different roles, interfaces, and objects in a way that facilitates
the desired interactions, problems and task durations.  We simulate roles using state
machines. Actor is the chosen alias for this state machine.  Actors specifically
symbolize Mealy machines, a type of state machine, represented by equations
\ref{eq:mealymachine}, \ref{eq:mealymachine2}.  Where $S$ is a set of states,
$S_0$ the start state,  $\Sigma_{A}$ the set of all Actor inputs, $\lambda_{A}$
the set of all Actor outputs, and $T$ a transition matrix which specifies the outputs
for any state transition.

\begin{equation}
	Actor = (S, S_0, \Sigma_A, \Lambda_A, T)
\label{eq:mealymachine}
\end{equation}

\begin{equation}
	T : S \times \Sigma_A \Rightarrow S \times \Lambda_A
\label{eq:mealymachine2}
\end{equation}

Events are Moore State machines that spontaneously change
state provided the appropriate conditions of the simulation are
met.

Simulating the passage of time provides a metric whereby
we can monitor the interactions between Actors in our model.
Each action an Actor can take is assigned a range spanning
the minimum and maximum time required to complete thereby
inserting non-determinism into the system.

Each Actor implements the IActor interface with the
methods: processNextState and processInputs. The processNextState
method moves the actor into its next state, generating outputs
and setting the next state to a default value and duration. The
processInputs method then looks at its inputs and determines
what the next state should be and when it should occur. This
method also generates additional outputs.

Each Event implements the IEvent interface. The IEvent
interface is fairly similar to the IActor interface except it has
the method getCount. This makes it possible to insert multiple
events of the same type without having to instantiate entirely
new objects. Events are also given higher priority than Actors
ensuring that all applicable events execute prior to any actors
on a given time-step.

Each actor has a method getNextStateTime. This returns
the global time-step when the actor will change state. The
simulator takes the minimum value of all the nextStateTimes
and advances the global clock to that time. If however the time
outputted is 0 then the simulator treats that as a signal that
the model is done processing and terminates. This eliminates
unnecessary processing by ensuring the simulator runs when
the system is changing.

Figure 2 portrays the execution of a time step. The simulator
first processes the next state of any events that undergo a state change in that
time. The outputs of those events are stored in the Post Office to be accessed
by the Actors when applicable. The Post Office stores the current inputs to each
Actor as well as the inputs that are to be processed on the
next time step. Next the Simulator calls processNextState on
each of the actors, updating their outputs in the Post Office.
The Post Office will then load all the next state inputs into the
current inputs making them visible to the actors. This method
of passing information makes it possible to provide the illusion
of concurrency to each of the actors in the model. The Actors
then each call processInputs. Once each Actor has evaluated
its inputs and made any changes the simulator checks if there
are any future time-steps to evaluate and if not it terminates
the imulation.

The main weakness imposed by the methods we used here
is that there is no framework already in place. This also is our
main strength. Languages such as Brahms are highly structured
and so there is a significant amount of work already done for
any system that uses that language but by the same point if a
slight change in the execution framework becomes necessary
it is virtually impossible to implement. In our system such
changes are fairly easily adapted.


\section{WiSAR UAS Model}

This section describes how we modeled the WiSAR UAS
using the framework that was previously mentioned. Due to
the size of the model this section does not contain the full
detail of the work that was done. Instead we have condensed the process into a
few key concepts which are explained with real examples from the actual modeling process.

\subsection{Actors}

Choosing the core actors was not a trivial task, because we
were looking for a level of abstraction that gave results without
adding unwanted complexity to the model. The final model
simulates the following team of actors: the parent search (PS),
mission manager (MM), UAV operator (OP), video operator
(VO), operator GUI (OGUI), video operator GUI (VGUI), and
the UAV.
An example of the preferred level of abstraction is found
in our modeling of weather. We decided to model the effects
of weather as events on the UAV instead of creating a weather
actor. This reduces the number of actors, but limits our analysis
of weather effects on the entire system which we found
acceptable.
Another example was the addition of sub-actors to the UAV
actor. Sub-actors are parts of a more complex actor, in this
case the UAV. The sub-actors for UAV are the battery, flight
plan, height above ground, and the signal. Their inputs and
outputs are handled differently than a normal actor. These subactors inputs are
linked within the simulator to the UAV. The UAV also has specific modifications
that allow it to process all sub-actors before completing its own processing.
This level of abstraction reduced the very complex UAV actor into multiple,
simpler actors. This gave us confidence that this modeling
framework is robust enough to model anything we may need.
It also gave us a pattern for modeling the different levels of
abstraction that we desire.

\subsection{Events}

We used events for several different abstractions. The first
class of abstraction is the common event. These events are
common and expected within the WiSAR UAS. Examples are
receiving new search areas from the parent search or viewing
an anomaly on the video GUI. Before anomalies appear on the
video GUI the event class randomly determines, within a range,
how long the anomaly is visible. The video GUI receives input
when the anomaly becomes visible and when it is no longer
visible. This allowed us to add non-determinism to the core of
the model without complicating the actors.
The second class of abstraction is the uncommon event.
These are events which are outside normal operation. They
represent unforeseen problems that can occur at any time. In
essence these types of events push the actors into state spaces
that they would never reach during normal operation. Examples
are low height above ground, loss of signal, and early low
battery. If a low height above ground event is triggered the
operator must modify the UAV flight plan before the UAV
crashes. The sub-actor UAVHeightAboveGound receives the
event input and changes its internal state. It then watches the
UAV input to see which occurs first, a flight plan modification
or low height above ground complete. If the flight plan
modification is received, then the events input is ignored.
Otherwise the UAV crashes.

\subsection{Asserts}

The more complicated the model the more things that can
go wrong. Some errors are caused by coding bugs and some are
flaws in the model. Flaws in the model are extremely valuable,
but it can be challenging to tell them apart. To catch these
errors we use java asserts. JPF automatically halts processing
when it encounters a false assertion, allowing us to determine
if the error is a bug or a flaw.
In our model we have used asserts in two ways. The first is
detection of undesired state. If an actor enters an undesirable
state then an assertion halts the simulation. An example of
this is the UAV\_CRASHED state. The second way we
use asserts deal with inputs. Many operations are sequential
requiring an existing state before they can be performed. By
looking at inputs received we are able to tell if actors are
out of sync with one another. An example of this is the
OP\_TAKE\_OFF input for the UAV. If the UAV is already
airborne and it receives this input we know that the operator
is out of sync with the UAV.
Asserts are critical to debugging and verifying the model
and we found that having too many asserts is preferable to
having too few.

\section{Results}

In this section we present empirical results to demonstrate
that WiSAR UAS is modeled effectively using the approach we
have taken. We will demonstrate this using a brief case study
extracted from WiSAR UAS. We will then give an analysis of
the JPF results we obtained when we verified the model.

\subsection{Case Study: Anomaly Detection}

This scenario represents what should occur when the video
operator believes they see the target on the video GUI. Periodically during a
flight the UAV will fly over an anomaly. An anomaly can be either a false
positive or a true positive. Meaning that it is either the desired target or it is not.
If the video operator believes that it is the target then a flyby request
is made through the video GUI. This request is then made
visible to the operator through the operator GUI. When the
operator decides to perform the flyby request he signals this
through the operator GUI and begins to manually direct the
UAV to the location of the anomaly. While the operator is
directing the UAV the video operator closely examines the
video stream until the anomaly is visible again. The video
operator then decides if it is a true target sighting or a false
positive. The video operator communicates this to the operator
through the video GUI. If it was a target sighting then the
video operator passes the information to the mission manager
who then passes it to the parent search. This high level
view communicates the basic structure of the communication
between the different actors.

\subsection{Model Construction}

As mentioned in section V we use seven core actors in
our model. The anomaly detection effects every single one of
these actors. Because we already had the core actor classessetup before we
defined this part of the model it was a simple process of adding additional
states and transitions to our actors.
For the anomalies themselves we created an anomaly event
which sent output directly to the video GUI. We wanted to the
operator to non-deterministically choose if an anomaly was
not seen, seen as a possible target, seen as a likely target. We
were able to acheive this by generating a random probability
within a designated range. This means that when run by JPF
each of those probabilities will be explored. A small portion
of the model can be seen in figure 3.
While constructing this portion of our model we used mock
actors to represent some of the logic which belonged to the
core classes. This allowed us to get the model working before
we had finished coding. This proved to be very useful and we
can see how it can be an effective tool for future verification.
If we are not interested in the non-deterministic states of one
actor, or a portion of that actors state space, that portion of the
model can be replaced with a mock actor.
We did run into a few issues while coding the model. One
problem we found was inconsistency in our human memory
modeling. Without a strict grammar it is possible to do the
same thing in many different ways which leads to flaws in
the model. We also found that if we did not move logic into
sub-actors the complex actors began to be unmanageable. In
some cases moving logic into a sub-actor can be a difficult
task. Another problem we found was the lack of asserts for
invalid states and inputs. These asserts are a crucial part of
determining if the model is performing correctly yet we had
no way of enforcing that these asserts were placed into the
code.

\subsection{JPF Results}

After we had coded this portion of our model we began
testing the model using JPF. We found that using JPF made
it much easier to find bugs in the model. When we began
to verify the model one of the first occurences
discovered was infinite loops. This told us that something was
wrong. Typically these bug are caused by a failure to send the
correct output, in one case the infinite loop occurred when
the actor would change states too early. We discovered that
the default maximum duration for that state was set too low.
This represented a flaw in our model.
After we had fixed our bugs and changed some of our
default maximum durations we found that JPF

\section{Future Work}
As stated previously this work is the basis for research on
human machine interfaces to support combined human roles
that reduce operator workload. To acheive this end we feel that
the modeling framework we have presented would be more
beneficial if it formalized some of the practices we found to
be useful while modeling. We would also like the simulation
to check the connectivity of the model before running the
simulation to ensure that model is complete.

% Reminder: the "draftcls" or "draftclsnofoot", not "draft", class option
% should be used if it is desired that the figures are to be displayed while
% in draft mode.


% An example of a floating figure using the graphicx package.
% Note that \label must occur AFTER (or within) \caption.
% For figures, \caption should occur after the \includegraphics.
%
% \begin{figure}
% \centering
% \includegraphics[width=2.5in]{myfigure}
% where an .eps filename suffix will be assumed under latex,
% and a .pdf suffix will be assumed for pdflatex
% \caption{Simulation Results}
% \label{fig_sim}
% \end{figure}


% An example of a double column floating figure using two subfigures.
% (The subfigure.sty package must be loaded for this to work.)
% The subfigure \label commands are set within each subfigure command, the
% \label for the overall fgure must come after \caption.
% \hfil must be used as a separator to get equal spacing
%
% \begin{figure*}
% \centerline{\subfigure[Case I]{\includegraphics[width=2.5in]{subfigcase1}
% where an .eps filename suffix will be assumed under latex,
% and a .pdf suffix will be assumed for pdflatex
% \label{fig_first_case}}
% \hfil
% \subfigure[Case II]{\includegraphics[width=2.5in]{subfigcase2}
% where an .eps filename suffix will be assumed under latex,
% and a .pdf suffix will be assumed for pdflatex
% \label{fig_second_case}}}
% \caption{Simulation results}
% \label{fig_sim}
% \end{figure*}


% An example of a floating table. Note that, for IEEE style tables, the
% \caption command should come BEFORE the table. Table text will default to
% \footnotesize as IEEE normally uses this smaller font for tables.
% The \label must come after \caption as always.
%
% \begin{table}
% increase table row spacing, adjust to taste
% \renewcommand{\arraystretch}{1.3}
% \caption{An Example of a Table}
% \label{table_example}
% \begin{center}
% Some packages, such as MDW tools, offer better commands for making tables
% than the plain LaTeX2e tabular which is used here.
% \begin{tabular}{|c||c|}
% \hline
% One & Two\\
% \hline
% Three & Four\\
% \hline
% \end{tabular}
% \end{center}
% \end{table}


% conference papers do not normally have an appendix


% use section* for acknowledgement
\section*{Acknowledgment}
% optional entry into table of contents (if used)
% \addcontentsline{toc}{section}{Acknowledgment}
The authors would like to thank Neha Rungta of NASA Ames Intelligent
Systems Division for her help with JPF and Brahms.



% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
% \IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
% \IEEEtriggercmd{\enlargethispage{-5in}}


% references section
% NOTE: BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/


% can use a bibliography generated by BibTeX as a .bbl file
% standard IEEE bibliography style from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/supported/IEEEtran/bibtex
% \bibliographystyle{IEEEtran.bst}
% argument is your BibTeX string definitions and bibliography database(s)
% \bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
\begin{thebibliography}{1}

\bibitem{IEEEhowto:kopka}
H.~Kopka and P.~W. Daly, \emph{A Guide to {\LaTeX}}, 3rd~ed.\hskip 1em plus
  0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.
\end{thebibliography}


% that's all folks
\end{document} 
